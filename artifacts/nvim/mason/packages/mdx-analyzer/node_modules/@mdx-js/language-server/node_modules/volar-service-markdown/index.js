"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = create;
const language_service_1 = require("@volar/language-service");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
const vscode_markdown_languageservice_1 = require("vscode-markdown-languageservice");
const vscode_uri_1 = require("vscode-uri");
const MarkdownIt = require("markdown-it");
const md = new MarkdownIt();
const organizeLinkDefKind = 'source.organizeLinkDefinitions';
function create({ documentSelector = ['markdown'], fileExtensions = [
    'md',
    'mkd',
    'mdwn',
    'mdown',
    'markdown',
    'markdn',
    'mdtxt',
    'mdtext',
    'workbook',
], getDiagnosticOptions = async (_document, context) => {
    return await context.env.getConfiguration?.('markdown.validate');
}, } = {}) {
    return {
        name: 'markdown',
        capabilities: {
            codeActionProvider: {
                resolveProvider: true,
                codeActionKinds: [
                    organizeLinkDefKind,
                    'quickfix',
                    'refactor',
                ],
            },
            completionProvider: {
                triggerCharacters: ['.', '/', '#'],
            },
            definitionProvider: true,
            diagnosticProvider: {
                interFileDependencies: false,
                workspaceDiagnostics: false,
            },
            documentHighlightProvider: true,
            documentLinkProvider: {
                resolveProvider: true,
            },
            documentSymbolProvider: true,
            foldingRangeProvider: true,
            hoverProvider: true,
            referencesProvider: true,
            fileReferencesProvider: true,
            renameProvider: {
                prepareProvider: true,
            },
            fileRenameEditsProvider: true,
            selectionRangeProvider: true,
            workspaceSymbolProvider: {},
        },
        create(context) {
            const logger = {
                level: vscode_markdown_languageservice_1.LogLevel.Off,
                log(_logLevel, message) {
                    context.env.console?.log(message);
                }
            };
            const parser = {
                slugifier: vscode_markdown_languageservice_1.githubSlugifier,
                async tokenize(document) {
                    return await md.parse(document.getText(), {});
                }
            };
            const workspace = getMarkdownWorkspace();
            const mdLs = (0, vscode_markdown_languageservice_1.createLanguageService)({
                logger,
                parser,
                workspace: workspace.workspace,
            });
            const firedDocumentChanges = new Map();
            const fsSourceScripts = new Map();
            const fileWatcher = context.env.onDidChangeWatchedFiles?.(event => {
                for (const change of event.changes) {
                    fsSourceScripts.delete(change.uri);
                }
            });
            const codeActionDocuments = new Map();
            return {
                dispose() {
                    mdLs.dispose();
                    workspace.dispose();
                    fileWatcher?.dispose();
                },
                provide: {
                    'markdown/languageService': () => mdLs
                },
                provideCodeActions(document, range, context, token) {
                    if (prepare(document)) {
                        if (context.only?.some(kind => kind === 'source' || kind.startsWith('source.'))) {
                            const action = {
                                title: 'Organize link definitions',
                                kind: organizeLinkDefKind,
                                data: { uri: document.uri },
                            };
                            codeActionDocuments.set(action.title, new WeakRef(document));
                            return [action];
                        }
                        return mdLs.getCodeActions(document, range, context, token);
                    }
                },
                async resolveCodeAction(codeAction, token) {
                    if (codeAction.kind === organizeLinkDefKind) {
                        const data = codeAction.data;
                        const document = codeActionDocuments.get(codeAction.title)?.deref();
                        if (!document) {
                            return codeAction;
                        }
                        const edits = await mdLs.organizeLinkDefinitions(document, { removeUnused: true }, token);
                        codeAction.edit = {
                            changes: {
                                [data.uri]: edits,
                            },
                        };
                        return codeAction;
                    }
                    return codeAction;
                },
                async provideCompletionItems(document, position, _context, token) {
                    if (prepare(document)) {
                        const items = await mdLs.getCompletionItems(document, position, {}, token);
                        return {
                            isIncomplete: false,
                            items
                        };
                    }
                },
                async provideDefinition(document, position, token) {
                    if (prepare(document)) {
                        let locations = await mdLs.getDefinition(document, position, token);
                        if (!locations) {
                            return;
                        }
                        if (!Array.isArray(locations)) {
                            locations = [locations];
                        }
                        return locations.map(location => ({
                            targetUri: location.uri,
                            targetRange: location.range,
                            targetSelectionRange: location.range,
                        }));
                    }
                },
                async provideDiagnostics(document, token) {
                    if (prepare(document)) {
                        const configuration = await getDiagnosticOptions(document, context);
                        if (configuration) {
                            return mdLs.computeDiagnostics(document, configuration, token);
                        }
                    }
                },
                provideDocumentHighlights(document, position, token) {
                    if (prepare(document)) {
                        return mdLs.getDocumentHighlights(document, position, token);
                    }
                },
                async provideDocumentLinks(document, token) {
                    if (prepare(document)) {
                        return await mdLs.getDocumentLinks(document, token);
                    }
                },
                provideDocumentSymbols(document, token) {
                    if (prepare(document)) {
                        return mdLs.getDocumentSymbols(document, { includeLinkDefinitions: true }, token);
                    }
                },
                provideFileReferences(document, token) {
                    if (prepare(document)) {
                        return mdLs.getFileReferences(vscode_uri_1.URI.parse(document.uri), token);
                    }
                },
                provideFoldingRanges(document, token) {
                    if (prepare(document)) {
                        return mdLs.getFoldingRanges(document, token);
                    }
                },
                provideHover(document, position, token) {
                    if (prepare(document)) {
                        return mdLs.getHover(document, position, token);
                    }
                },
                provideReferences(document, position, referenceContext, token) {
                    if (prepare(document)) {
                        return mdLs.getReferences(document, position, referenceContext, token);
                    }
                },
                provideRenameEdits(document, position, newName, token) {
                    if (prepare(document)) {
                        return mdLs.getRenameEdit(document, position, newName, token);
                    }
                },
                provideRenameRange(document, position, token) {
                    if (prepare(document)) {
                        return mdLs.prepareRename(document, position, token);
                    }
                },
                async provideFileRenameEdits(oldUri, newUri, token) {
                    const result = await mdLs.getRenameFilesInWorkspaceEdit([{ oldUri, newUri }], token);
                    return result?.edit;
                },
                provideSelectionRanges(document, positions, token) {
                    if (prepare(document)) {
                        return mdLs.getSelectionRanges(document, positions, token);
                    }
                },
                provideWorkspaceSymbols(query, token) {
                    return mdLs.getWorkspaceSymbols(query, token);
                },
                async resolveDocumentLink(link, token) {
                    return await mdLs.resolveDocumentLink(link, token) ?? link;
                }
            };
            function prepare(document) {
                if (matchDocument(documentSelector, document)) {
                    if (firedDocumentChanges.get(document.uri) !== document.version) {
                        firedDocumentChanges.set(document.uri, document.version);
                        workspace.onDidChangeMarkdownDocument.fire(document);
                    }
                    return true;
                }
                return false;
            }
            function getMarkdownWorkspace() {
                const onDidChangeMarkdownDocument = new vscode_jsonrpc_1.Emitter();
                const onDidCreateMarkdownDocument = new vscode_jsonrpc_1.Emitter();
                const onDidDeleteMarkdownDocument = new vscode_jsonrpc_1.Emitter();
                const { fs, onDidChangeWatchedFiles } = context.env;
                const fileWatcher = onDidChangeWatchedFiles?.(event => {
                    for (const change of event.changes) {
                        switch (change.type) {
                            case 2: {
                                const document = getTextDocument(vscode_uri_1.URI.parse(change.uri));
                                if (document) {
                                    onDidChangeMarkdownDocument.fire(document);
                                }
                                break;
                            }
                            case 1: {
                                const document = getTextDocument(vscode_uri_1.URI.parse(change.uri));
                                if (document) {
                                    onDidCreateMarkdownDocument.fire(document);
                                }
                                break;
                            }
                            case 3: {
                                onDidDeleteMarkdownDocument.fire(vscode_uri_1.URI.parse(change.uri));
                                break;
                            }
                        }
                    }
                });
                const workspace = {
                    async getAllMarkdownDocuments() {
                        // TODO: Add opened files (such as untitled files)
                        // const openTextDocumentResults = this.documents.all()
                        // 	.filter(doc => this.isRelevantMarkdownDocument(doc));
                        return (await Promise.all(context.env.workspaceFolders.map(findMarkdownFilesInWorkspace))).flat();
                    },
                    getContainingDocument(resource) {
                        const decoded = context.decodeEmbeddedDocumentUri(resource);
                        if (decoded) {
                            return {
                                uri: decoded[0],
                                children: [],
                            };
                        }
                    },
                    hasMarkdownDocument(resource) {
                        const document = getTextDocument(resource);
                        return Boolean(document && matchDocument(documentSelector, document));
                    },
                    onDidChangeMarkdownDocument: onDidChangeMarkdownDocument.event,
                    onDidCreateMarkdownDocument: onDidCreateMarkdownDocument.event,
                    onDidDeleteMarkdownDocument: onDidDeleteMarkdownDocument.event,
                    async openMarkdownDocument(resource) {
                        return await getTextDocument(resource);
                    },
                    async readDirectory(resource) {
                        const directory = await fs?.readDirectory(resource) ?? [];
                        return directory
                            .filter(file => file[1] !== 0)
                            .map(([fileName, fileType]) => [
                            fileName,
                            { isDirectory: fileType === 2 }
                        ]);
                    },
                    async stat(resource) {
                        const stat = await fs?.stat(resource);
                        if (stat?.type === 0) {
                            return;
                        }
                        return { isDirectory: stat?.type === 2 };
                    },
                    workspaceFolders: context.env.workspaceFolders,
                };
                return {
                    workspace,
                    onDidChangeMarkdownDocument,
                    onDidCreateMarkdownDocument,
                    onDidDeleteMarkdownDocument,
                    dispose() {
                        fileWatcher?.dispose();
                        onDidDeleteMarkdownDocument.dispose();
                        onDidCreateMarkdownDocument.dispose();
                        onDidChangeMarkdownDocument.dispose();
                    },
                };
            }
            async function findMarkdownFilesInWorkspace(folder) {
                const { fs } = context.env;
                const files = await fs?.readDirectory(folder) ?? [];
                const docs = [];
                await Promise.all(files.map(async ([fileName, fileType]) => {
                    if (fileType === 2 && fileName !== 'node_modules') {
                        for (const doc of await findMarkdownFilesInWorkspace(vscode_uri_1.Utils.joinPath(folder, fileName))) {
                            docs.push(doc);
                        }
                    }
                    else if (fileExtensions.some(ext => fileName.endsWith('.' + ext))) {
                        const fileUri = vscode_uri_1.Utils.joinPath(folder, fileName);
                        let sourceScript = context.language.scripts.get(fileUri);
                        if (!sourceScript) {
                            if (!fsSourceScripts.has(fileUri.toString())) {
                                fsSourceScripts.set(fileUri.toString(), undefined);
                                const fileContent = await fs?.readFile(fileUri);
                                if (fileContent !== undefined) {
                                    fsSourceScripts.set(fileUri.toString(), context.language.scripts.set(fileUri, {
                                        getText(start, end) {
                                            return fileContent.substring(start, end);
                                        },
                                        getLength() {
                                            return fileContent.length;
                                        },
                                        getChangeRange() {
                                            return undefined;
                                        },
                                    }));
                                    context.language.scripts.delete(fileUri);
                                }
                            }
                            sourceScript = fsSourceScripts.get(fileUri.toString());
                        }
                        if (sourceScript?.generated) {
                            for (const virtualCode of (0, language_service_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
                                if (matchDocument(documentSelector, virtualCode)) {
                                    const uri = context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id);
                                    const doc = context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot);
                                    docs.push(doc);
                                }
                            }
                        }
                        else if (sourceScript) {
                            const doc = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
                            if (doc && matchDocument(documentSelector, doc)) {
                                docs.push(doc);
                            }
                        }
                    }
                }));
                return docs;
            }
            function getTextDocument(uri) {
                const decoded = context.decodeEmbeddedDocumentUri(uri);
                if (decoded) {
                    const sourceScript = context.language.scripts.get(decoded[0]);
                    const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                    if (virtualCode) {
                        return context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot);
                    }
                }
                else {
                    const sourceScript = context.language.scripts.get(uri);
                    if (sourceScript) {
                        return context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
                    }
                }
            }
        },
    };
}
function matchDocument(selector, document) {
    for (const sel of selector) {
        if (sel === document.languageId || (typeof sel === 'object' && sel.language === document.languageId)) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=index.js.map